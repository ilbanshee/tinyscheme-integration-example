
<!-- saved from url=(0053)http://www.xs4all.nl/~evbergen/nonrecursive-make.html -->
<HTML><!-- Document generated by decorate.pl --><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>Implementing non-recursive make</TITLE>
<META name="DESCRIPTION" contents="How to successfully implement single session builds">
<META name="KEYWORDS" contents="Non-recursive, single session, make, makefiles">
</HEAD><!--
<BODY BGCOLOR="#6b7eb2" TEXT="#000000" BACKGROUND="images/back.jpg"
      LINK="#0043ff" VLINK="#0043ff" ALINK="#6b7eb2">
--><BODY bgcolor="#6b7eb2" text="#000000" link="#0043ff" vlink="#0043ff" alink="#6b7eb2">

<!-- Table on left for menu table -->

<TABLE border="0" align="LEFT" cellpadding="4" cellspacing="6">
<TBODY><TR bgcolor="#ffffff" align="CENTER"><TD>

<!-- Generated by menuize.pl -->

<TABLE border="0" cellpadding="1" cellspacing="0"><TBODY><TR><TD align="LEFT">
<FONT size="+1"><B>Emile van Bergen</B></FONT><BR>
<BR>
<A href="http://www.xs4all.nl/~evbergen/about-me.html"><B>About me</B></A><BR>
<BR>
<A href="http://www.xs4all.nl/~evbergen/software.html"><B>Software</B></A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/radius-pppd.html">RADIUS for pppd</A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/i386-debug.html">i386 debugger</A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/html-menus.html">HTML menus</A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/openradius/index.html">OpenRADIUS<B>...</B></A><BR>
<BR>
<FONT color="#6b7eb2"><B>Technical articles</B></FONT><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/configuration-data.html">Configuration data</A><BR>
&nbsp;&nbsp;&nbsp;<FONT color="#6b7eb2">Non-recursive make</FONT><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/unix-signals.html">Signals and Select</A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/debian-gui-terminal.html">Linux GUIs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/debian-gui-terminal.html"><I>Library problems</I></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/groklaw-gui-terminal.html"><I>The GUI terminal</I></A><BR>
<BR>
<B>Work</B><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.e-advies.nl/activities.html">E-Advies<B>...</B></A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/EvB-cv-current-ned.pdf">CV (NL, pdf)<B>...</B></A><BR>
&nbsp;&nbsp;&nbsp;<A href="http://www.xs4all.nl/~evbergen/EvB-cv-current-eng.pdf">Resume (pdf)<B>...</B></A><BR>
<BR>
</TD></TR></TBODY></TABLE>

<!-- End of table on left -->

</TD></TR>
</TBODY></TABLE>

<!-- Table on right for document table -->

<TABLE border="0" align="LEFT" cellpadding="4" cellspacing="6">
<TBODY><TR bgcolor="#ffffff" align="LEFT"><TD>

<!-- Document table -->

<TABLE border="0" cellpadding="1" cellspacing="0">

<!-- Title row -->

<TBODY><TR bgcolor="#ffffff" valign="TOP">

<TD>
<FONT color="#000000" size="+1"><B>
Implementing non-recursive make
</B></FONT><HR noshade="" size="1">
</TD>
</TR>

<!-- Empty row -->

<TR><TD><BR><BR></TD></TR>

<!-- Document row -->

<TR><TD>




<H4>0. Introduction</H4>
<P>
If you&#39;re a regular Unix 
<A href="http://citeseer.nj.nec.com/feldman79make.html">Make</A>
user and you haven&#39;t read the excellent paper 
<A href="http://www.tip.net.au/~millerp/rmch/recu-make-cons-harm.html">Recursive Make Considered Harmful</A> by Peter Miller yet,
consider doing so first, and then return here. I&#39;m not going to present
the issues in that paper here again, but I will to show how you can put the
ideas described there to use, without some of the drawbacks that come with
the implementation given by the paper.

<BR>&nbsp;
</P><H4>1. Practical problems</H4>
<P>
The most basic problem to overcome when implementing single-session make is to
avoid flattening your directory structure, while joining the dependency
information present in each subdirectory in a single tree. That is, you not
only want to keep your subdirectories around, but also want to keep them
separate as far as their contents are concerned. You should be able to have
both an <TT>ant/localfile.h</TT> and a <TT>bee/localfile.h</TT>, and a way for
the sources in <TT>ant</TT> and <TT>bee</TT> to include the local header,
without knowing which directory it&#39;s in.

</P><P>
That means, among other things, that you&#39;ll want to avoid having to put every
directory in your tree in your include path. And simply using local includes,
<TT>#include &quot;localfile.h&quot;</TT>, does not solve the problem either, at least
not portably. That is because while building, the current directory as seen
by the compiler remains at the root of your project tree, and a lot of C
preprocessors will look there and not in the directory the current source file
is in when they see a local include.

</P><P>
The same story can be held for the Makefile fragments you put in each 
directory. Putting absolute paths in them is not an option, because you
loose the freedom to move subtrees around.

</P><P>
The original paper doesn&#39;t address those issues, but using 
<A href="http://www.gnu.org/software/make/make.html">GNU Make</A>, I believe 
they can be handled effectively.

<BR>&nbsp;
</P><H4>2. The solution</H4>
<P>
Basically, what&#39;s needed to tackle these issues is a variable that tracks the
&#39;current directory&#39; while the source tree is traversed and makefile fragments
are included. This variable can then be used in describing dependency relations
in a relative fashion, and in the include path for the compiler in build
recipes.

</P><P>
Two problems arise with that. The first one being that you need a stack-like
construct to save the variable that holds the current directory while
traversing the source tree using makefile includes. 

</P><P>
The second is that include paths must be specified on the compiler command
line, that is in the build recipes. However, variables used in recipes are only
substituted at build time, so the various values that the current
directory-variable had while assembling the dependency tree, will be long
forgotten. In other words, how do we get the &quot;current&quot; directory on the
compiler command line?

</P><P>
Luckily, GNU Make provides two features help solve those problems. Using
target-specific variable assignments (only correctly implemented in version
3.79 and later), we can get the &quot;current&quot; directory into the build recipes.
And using string concatenation, suffix stripping and double indirection, we can
implement a stack to save the current directory on while including Makefile
fragments in subdirectories.

<BR>&nbsp;
</P><H4>3. How to put that together</H4>
<P>
These examples are all taken from OpenRADIUS 0.9.5, which uses the concepts
described here in its build system.

</P><H4>3.1. The main Makefile</H4>
<P>
Basically, we start out with a regular Makefile, which defines a few things,
such as the tools we&#39;ll use, like this:
<SMALL><PRE>
### Build flags for all targets
#
CF_ALL          = -g -Wall
LF_ALL          = 
LL_ALL          =

### Build tools
# 
CC              = ./build/ccd-gcc
INST		= ./build/install
COMP            = $(CC) $(CF_ALL) $(CF_TGT) -o $@ -c $&lt;
LINK            = $(CC) $(LF_ALL) $(LF_TGT) -o $@ $^ $(LL_TGT) $(LL_ALL)
COMPLINK        = $(CC) $(CF_ALL) $(CF_TGT) $(LF_ALL) $(LF_TGT) -o $@ $&lt; $(LL_TGT) $(LL_ALL)

### Standard parts
#
include Rules.mk
</PRE></SMALL>
</P><CENTER>Fig. 1: The main
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/Makefile"><TT>Makefile</TT></A></CENTER>

<P>
After these macros, which can be platform- and configuration specific, you
continue by including the generic Rules.mk, which will include additional
Rules.mk files in each subdirectory. First we examine the tools used above
a little closer though.

</P><H4>3.2. The compile script</H4>
<P>
The command used as $(CC) above is a wrapper script that invokes the compiler
and outputs any extra dependency information that is found while compiling, in
a format suitable for inclusion in Makefile fragments. Some compilers can do
that on the fly, but omit directory names or put things in the wrong place in
other ways; other systems will need a separate invocation of the preprocessor
or even a completely separate tool. 

</P><P>
See 
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/build/ccd-gcc"><TT>build/ccd-gcc</TT></A> 
for a version of the script tailored for GCC, and 
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/build/ccd-osf"><TT>build/ccd-osf</TT></A>
for a version that uses Compaq&#39;s C compiler. The idea in each case being that
the script should hide the details of automatic dependency generation from the
rest of the build system.

</P><P>
If you want to build a script for your own compiler, the requirement is that it
allows both compiling and compiling and linking in one step, and that a .d file
must be generated containing the target&#39;s (extra) dependencies, with the same
base name as the target which is specified using the -o command line option.

</P><P>
For example, assume <TT>dir/file1.c</TT> includes <TT>header1.h</TT> and
<TT>header2.h</TT> locally. Then, <TT>ccd-mycc -o dir/some_executable
dir/file1.c dir/file2.c otherdir/file3.o otherdir/file4.a</TT> must generate
both the executable and a file <TT>dir/some_executable.d</TT>, which contains
all the dependencies for the target, and each prerequisite as an empty target
on its own, so that GNU Make will silently consider the target out of date if a
prerequisite doesn&#39;t exist:

</P><PRE>dir/some_executable dir/some_executable.d: dir/file1.c dir/file2.c \
    otherdir/file3.o otherdir/file4.a dir/header1.h dir/header2.h
dir/file1.c:
dir/file2.c:
otherdir/file3.o:
otherdir/file4.a:
dir/header1.h:
dir/header2.h:
</PRE>

Of course, the dependencies outside of the headers are entirely optional,
because in they will already be given by the makefile fragment, but most
compilers or mkdep tools will generate them anyway, and including them doesn&#39;t
do any harm. No need to take them out.

<H4>3.3. The install script</H4>
<P>
A very irritating aspect of trying to build portable packages is the fact that
the Unix &quot;install&quot; command is highly non-portable, and that the few portable
features hardly surpass those of &quot;cp&quot;. Finding GNU Automake&#39;s install-sh not
very satisfactory either, I decided to write a very powerful yet completely
portable install command as a POSIX /bin/sh script. It creates directories
recursively where needed, but does not assume a working mkdir -p command.  It&#39;s
simple but versatile.

</P><P>
See the documentation included at the top of the 
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/build/install"><TT>build/install</TT></A>
script itself.

</P><H4>3.4. The top-level Rules.mk</H4>
<P>
As can be seen at the bottom of the main makefile, a file named Rules.mk
is included, which starts the recursive include process. It also contains a few
basic recipes and specifies the final targets:
<SMALL><PRE>
# Standard things

.SUFFIXES:
.SUFFIXES:	.c .o

all:		targets


# Subdirectories, in random order

dir	:= ant
include		$(dir)/Rules.mk
dir	:= bee
include		$(dir)/Rules.mk


# General directory independent rules

&percnt;.o:		&percnt;.c
		$(COMP)

&percnt;:		&percnt;.o
		$(LINK)

&percnt;:		&percnt;.c
		$(COMPLINK)


# The variables TGT_*, CLEAN and CMD_INST* may be added to by the Makefile
# fragments in the various subdirectories.

.PHONY:		targets
targets:	$(TGT_BIN) $(TGT_SBIN) $(TGT_ETC) $(TGT_LIB)

.PHONY:		clean
clean:
		rm -f $(CLEAN)

.PHONY:		install
install:	targets 
		$(INST) $(TGT_BIN) -m 755 -d $(DIR_BIN)
		$(CMD_INSTBIN)
		$(INST) $(TGT_SBIN) -m 750 -d $(DIR_SBIN)
		$(CMD_INSTSBIN)
ifeq ($(wildcard $(DIR_ETC)/*),)
		$(INST) $(TGT_ETC) -m 644 -d $(DIR_ETC)
		$(CMD_INSTETC)
else
		@echo Configuration directory $(DIR_ETC) already present -- skipping
endif
		$(INST) $(TGT_LIB) -m 750 -d $(DIR_LIB)
		$(CMD_INSTLIB)


# Prevent make from removing any build targets, including intermediate ones

.SECONDARY:	$(CLEAN)
</PRE></SMALL>
</P><CENTER>Fig. 2: A top-level
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/Rules.mk"><TT>Rules.mk</TT></A></CENTER>

<H4>3.5. The per-directory makefile fragments</H4>
<P>
The real work is done by the Rules.mk files present in the directories that
hold actual source files. As an example, let&#39;s examine the <TT>Rules.mk</TT>
that is in OpenRADIUS 0.9.5&#39;s subdirectory <TT>common</TT>. That directory
builds an archive (.a) or library of frequently reused objects.

Each Rules.mk begins with a standard part that saves the variable <TT>$(d)</TT>
that holds the current directory on the stack, and sets it to the current
directory given in <TT>$(dir)</TT>, which was passed as a parameter by the
parent <TT>Rules.mk</TT>:
<SMALL><PRE>
# Standard things

sp 		:= $(sp).x
dirstack_$(sp)	:= $(d)
d		:= $(dir)

</PRE></SMALL>
(Then, if this directory has any subdirectories of its own, we list them here:)
<SMALL><PRE>
# Subdirectories, in random order

dir	:= $(d)/test
include		$(dir)/Rules.mk

</PRE></SMALL>
(Next, we create an immediately evaluated variable <TT>$(OBJS_common)</TT> that
holds all the objects in that directory. We also create
<TT>$(DEPS_common)</TT>, which lists any automatic dependency files generated
later on. To the global variable <TT>$(CLEAN)</TT>, we add the files that the
rules present here may create, i.e.  the ones we want deleted by a <TT>make
clean</TT> command.)
<SMALL><PRE>
# Local variables

OBJS_$(d)	:= $(d)/debug.o $(d)/md5.o $(d)/misc.o \
		   $(d)/ringbuf.o $(d)/textfile.o $(d)/subprocs.o \
		   $(d)/metadata.o $(d)/metatype.o \
		   $(d)/metadict.o $(d)/metaops.o
DEPS_$(d)	:= $(OBJS_$(d):&percnt;=&percnt;.d)

CLEAN		:= $(CLEAN) $(OBJS_$(d)) $(DEPS_$(d)) \
		   $(d)/common.a $(d)/platform.h

</PRE></SMALL>
(Now we list the dependency relations relevant to the files in this 
subdirectory. Most importantly, while generating the objects listed here,
we want to set the target-specific compiler flags <TT>$(CF_TGT)</TT> to
include a flag that adds this directory to the include path, so that 
local headers may be included using <TT>#include &lt;localfile.h&gt;</TT>,
which is, as said, more portable than local includes when the source directory
is not the current directory.)
<SMALL><PRE>
# Local rules

$(OBJS_$(d)):	CF_TGT := -I$(d)

$(d)/common.a:	$(OBJS_$(d))
		$(ARCH)

</PRE></SMALL>
(Here we try to include any automatically generated dependency files
for the objects we know of, but we don&#39;t worry if they haven&#39;t been generated
yet. In that case the .o files shouldn&#39;t exist either, so rebuilding will
happen anyway, which also generates the .d files.
</P><P>
As a last step, we restore the value of the current directory variable <TT>$(d)</TT> by taking it from the current location on the stack, and we &quot;decrement&quot;
the stack pointer by stripping away the <TT>.x</TT> suffix we added at the top
of this file.)
<SMALL><PRE>
# Standard things

-include	$(DEPS_$(d))

d		:= $(dirstack_$(sp))
sp		:= $(basename $(sp))
</PRE></SMALL>
</P><CENTER>Fig. 3: An example of a
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/subdir-Rules.mk-sample1"><TT>Rules.mk</TT></A> 
file</CENTER>

<P>
After doing all this, we can have other files safely depend on
<TT>common/common.a</TT>; we know that all dependency relations below it are
fully described. As a last example, let&#39;s examine another <TT>Rules.mk</TT>,
which is used to generate OpenRADIUS&#39; <TT>radclient</TT> tool:
<SMALL><PRE>
# Standard things

sp 		:= $(sp).x
dirstack_$(sp)	:= $(d)
d		:= $(dir)


# Local rules and targets

TGTS_$(d)	:= $(d)/radclient
DEPS_$(d)	:= $(TGTS_$(d):&percnt;=&percnt;.d)

TGT_BIN		:= $(TGT_BIN) $(TGTS_$(d))
CLEAN		:= $(CLEAN) $(TGTS_$(d)) $(DEPS_$(d))

$(TGTS_$(d)):	$(d)/Rules.mk

$(TGTS_$(d)):	CF_TGT := -Icommon -DRADDB=\&quot;$(DIR_ETC)\&quot;
$(TGTS_$(d)):	LL_TGT := $(S_LL_INET) common/common.a
$(TGTS_$(d)):	$(d)/radclient.c common/common.a
		$(COMPLINK)


# Standard things

-include	$(DEPS_$(d))

d		:= $(dirstack_$(sp))
sp		:= $(basename $(sp))
</PRE></SMALL>
</P><CENTER>Fig. 4: A
<A href="http://www.xs4all.nl/~evbergen/download/nonrecursive-make/subdir-Rules.mk-sample2"><TT>Rules.mk</TT></A> file for an executable target</CENTER>

<P>
As you can see, referring to files in directories other than the local one
still needs to be done using a paths relative to the root of the project tree. 
I don&#39;t see that as much of a problem; a little compartimentalization is in
most cases exactly what you want to want to achieve by splitting your project
across subdirectories. If you really want to refer to a directory relative to
the local one, you could use a construct like <TT>$(d)/../common/common.a</TT>.

</P><P>
The most important thing here though, is that you can see that this Makefile
fragment and the source files mentioned in it can remain completely unaware of
their whereabouts in the project tree. And that&#39;s an important maintainability
feature, which was left unaddressed by the solutions in &quot;Recursive Make
Considered Harmful&quot;.

<BR>&nbsp;
</P><P align="RIGHT">
<I>Emile van Bergen, 2002/11/05</I>
</P>

<BR><BR> <BR><BR> <BR><BR> <BR><BR> 


<!-- End of document table -->

<SCRIPT language="JavaScript">
<!--
url='http://host.e-advies.nl/track/blackpixel.gif?ref=' + escape(document.referrer);
document.write('<IMG SRC="' + url +  '" WIDTH=1 HEIGHT=1 ALT="s">');
// -->
</SCRIPT><IMG src="./Implementing non-recursive make_files/blackpixel.gif" width="1" height="1" alt="s">
<NOSCRIPT></NOSCRIPT>

<P align="CENTER"><FONT color="#6b7eb2" size="-2">Generated on Wed Aug 31 17:01:55 2005 by <A href="http://www.xs4all.nl/~evbergen/tools/decorate.pl">decorate.pl</A> / <A href="http://www.xs4all.nl/~evbergen/tools/menuize.pl">menuize.pl</A></FONT>

</P></TD></TR></TBODY></TABLE>

<!-- End of table on right -->

</TD></TR></TBODY></TABLE>




</BODY></HTML>